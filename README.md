# W25Q128 Flash 视频存储方案
> 项目技术文档 | 作者：Passion | 日期：2025-12-19
# 概述
本文档介绍了如何在W25Q128 SPI Flash芯片中存储和管理
视频数据的方案。该方案设计了一个简单的文件头结构，用于标识视频文件及其帧数，并定义了数据的组织方式。
# 文件头设计
文件头由3个字节组成：
1. 魔术字节（1字节）：0xAA
   - 用于标识该文件为有效的视频文件。
2. 帧数（2字节）：表示视频的总帧数，采用小端格式存储。
   - 低字节：存储帧数的低8位。
    - 高字节：存储帧数的高8位。
# 数据组织
视频数据紧随文件头之后存储。每帧数据占用1024字节，按顺序排列。
# 存储布局

W25Q128地址布局：
+------------------+
| 文件头(3字节)    | <- Address
+------------------+
| 第1帧(1024字节)  | <- Address + 3
+------------------+
| 第2帧(1024字节)  | <- Address + 1027
+------------------+
| ...              |
+------------------+*/
# 常见问题：
```c
1.为什么帧数量需要两字节？
		1个字节=8位=255帧，成千上万帧的视频255不够。
		2个字节=65535帧max。低八位，高八位
	小端格式（低位先存高位后存）如果大端格式，需要俩颠倒一下。
		eg.1000帧  temp[1] = 1000&0xFF  			  低八位=0xE8（232）
					temp[2] = (1000>>8) &0xFF		  高八位=0x03（3）
					1000=3×256+232
				//恢复帧数
					frames=（temp[2]<<8)|temp[1]
							//= (0x03 << 8) | 0xE8 
							= 0x0300 | 0xE8 
							= 0x03E8 = 1000//
2.为什么用0xAA作为魔术字标识-10101010b，好识别。随机数据很少恰好为0xAA
			// 场景1：有效的视频文件 W25Q128地址0: 0xAA 0xE8 0x03 ...  // 识别为视频文件，正常播放
			// 场景2：未初始化的Flash区域  W25Q128地址0: 0xFF 0xFF 0xFF ...  // 擦除状态，不是视频文件
			// 场景3：随机数据  W25Q128地址0: 0x12 0x34 0x56 ...  // 不是0xAA，识别为无效文件
3.完整流程：定义文件头数组=调用函数读取数据【0xAA错误处理】，头文件数组被0xAA和低高八位数据赋值=播放逻辑（oledmodww
4.单位
		    帧1024个8位插排=1024字节00000000=8192位0/1；128*64/8=1024字节=1帧
5.位运算
		   或：只要一位为0，结果位=0 1000&0xFF作为滤嘴取低八位。---高八位的&0xFF完全可以省略，因为前面总是0.		  
		   1000的二进制：00000011 11101000  （16位表示）
			0xFF的二进制：00000000 11111111  （16位表示）
			按位与运算：
			00000011 11101000  (1000)&
			00000000 11111111  (0xFF)= 
			00000000 11101000  (232)
			移位：a>>b
			将a向右移动b位≈a/256；低位都会舍弃。左移乘，如果数据类型容量不够，高位舍弃，如果够，那么低位会补0
6.帧数，数据量（所有帧占用的存储空间）
		假设制作一个3秒视频：
	帧率：25帧/秒
	总帧数：3 × 25 = 75帧
	每帧大小：1024字节
	总数据量：75 × 1024 = 76,800字节
	存储到W25Q128：
	// 文件头计算：
		uint16_t frames = 75;
		uint8_t temp[3] = {0xAA, frames & 0xFF, (frames >> 8) & 0xFF};
		// temp[0] = 0xAA, temp[1] = 75, temp[2] = 0
	// 写入文件头
		W25Q128_unlimited_Program(0, temp, 3);
	// 写入75帧视频数据
		for(int i = 0; i < 75; i++) {
								// 每帧1024字节
			W25Q128_unlimited_Program(3 + i*1024, frame_data[i], 1024);}	
7.读取文件头和视频数据
    // 读取文件头
        uint8_t header[3];
        W25Q128_Read(0, header, 3);
        if(header[0] != 0xAA) {
            // 处理无效文件
        }
        uint16_t frames = (header[2] << 8) | header[1];
    // 读取视频数据
        for(int i = 0; i < frames; i++) {
            uint8_t frame_data[1024];
            W25Q128_Read(3 + i*1024, frame_data, 1024);
            // 处理每帧数据
        }
```
# 结论
通过上述设计，可以有效地在W25Q128 SPI Flash芯片中存储和
管理视频数据。文件头结构简洁明了，便于识别和处理视频文件。
该方案适用于嵌入式系统中的视频存储需求。
# 参考资料
1. W25Q128 数据手册
2. 嵌入式系统视频存储设计最佳实践
# 附录：代码示例
```c
// 写入视频文件头
void write_video_header(uint16_t frames) {
    uint8_t header[3];
    header[0] = 0xAA; // 魔术字节
    header[1] = frames & 0xFF; // 低字节
    header[2] = (frames >> 8) & 0xFF; // 高字节
    W25Q128_unlimited_Program(0, header, 3);
}
// 读取视频文件头
uint16_t read_video_header() {
    uint8_t header[3];
    W25Q128_Read(0, header, 3);
    if(header[0] != 0xAA) {
        // 处理无效文件
        return 0;
    }
    return (header[2] << 8) | header[1];
}
// 读取视频帧数据
void read_video_frames(uint16_t frames) {
    for(int i = 0; i < frames; i++) {
        uint8_t frame_data[1024];
        W25Q128_Read(3 + i*1024, frame_data, 1024);
        // 处理每帧数据
    }
}
```